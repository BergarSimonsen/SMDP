/*
 * generated by Xtext
 */
package org.xtext.example.mydsl.validation

import Configurator.BinaryConstraint
import Configurator.BinaryOperator
import Configurator.Literal
import Configurator.NamedElement
import Configurator.Parameter
import Configurator.ParameterIdentifier
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check
import Configurator.ConfiguratorPackage
import org.eclipse.emf.ecore.EStructuralFeature
import Configurator.impl.ConfiguratorPackageImpl
import Configurator.ConfiguratorModel
import org.xtext.example.mydsl.services.MyDslGrammarAccess.ConfiguratorModelElements
import org.eclipse.emf.codegen.ecore.genmodel.impl.Literals

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class MyDslValidator extends AbstractMyDslValidator {
	
	public static val INVALID_NAME = 'invalidName'
	
	
	// Ensure that correct operators are used for constraints
	@Check
	def constraint(BinaryConstraint it) {
		println("mathOperatorConstraint: " + mathOperatorConstraint(it))
		println("andOrOperatorConstraint: " + mathOperatorConstraint(it))
		(andOrOperatorConstraint(it)) || (mathOperatorConstraint(it))
	}
	
	// Enum can't be empty && all values in enum must have same type.
	@Check
	def constraint(Configurator.Enum it) {
		println("enumconstraint")
		if(!(values.size > 0 && values.forall[x | x.eClass == values.get(0).eClass])) 
			error("Enum.size must be > 0 and all enum values must have same typef", ConfiguratorPackage.Literals.ENUM__VALUES)
	}
	
	// Name must not be empty
	@Check
	def constraint(NamedElement it) {
		println("nameconstraint")
		if(!(name != null && !name.empty))
			error("Name must not be null or empty", ConfiguratorPackage.Literals.NAMED_ELEMENT__NAME)
	}
	
	// If parameter's type is enum, then enumCountConstraint should be met
	@Check
	def constraint(Parameter it) {
		println("parameterConstraint " + name)
		if(!(((type instanceof Configurator.Enum && enumCountConstraint) || !(type instanceof Configurator.Enum)) && (maxChosenValues >= minChosenValues)))
			error("some random error!!", ConfiguratorPackage.Literals.PARAMETER__MAX_CHOSEN_VALUES)
	}	
	
	// Catch all case for dynamic dispatch resolution
	@Check
	def constraint(EObject it) {
		println("default constraint")
		true
	}
	
	/////////////////////////////////////////////////////////////////////////////////
	// 		HELPER METHODS
	/////////////////////////////////////////////////////////////////////////////////
	
	// &&, || and XOR can only be used on binary constraints 
	def static boolean andOrOperatorConstraint(BinaryConstraint it) {
		println("andoroperatorconstraint")
		if(!((operator.equals(BinaryOperator.AND) || operator.equals(BinaryOperator.OR) || operator.equals(BinaryOperator.XOR))
		&&
		(leftOperand instanceof BinaryConstraint)
		&&
		(rightOperand instanceof BinaryConstraint))) {
			println("testing")
		}
	}
	
	// Math operators can only be used on values and parameters.
	// Literal values can only appear on the right side of the constraint
	def static boolean mathOperatorConstraint(BinaryConstraint it) {
		println("mathoperatorconstraint")
		(operator.equals(BinaryOperator.NOTEQUALS) || operator.equals(BinaryOperator.EQUALS) || operator.equals(BinaryOperator.GT) || operator.equals(BinaryOperator.GTEQ) || operator.equals(BinaryOperator.LT) || operator.equals(BinaryOperator.LTEQ)) 
		&& 
		(leftOperand instanceof ParameterIdentifier && (rightOperand instanceof Literal || rightOperand instanceof ParameterIdentifier))
	}
	
	// parameter.minChosenValues <= parameter.enum.values.size <= parameter.maxChosenValues
	def static boolean enumCountConstraint(Parameter it) {
		println("enumcountconstraint " + name)
		val enumType = type as Configurator.Enum
		(enumType.values.size >= maxChosenValues) && (enumType.values.size >= minChosenValues)
	}

//  public static val INVALID_NAME = 'invalidName'

//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
}
